#This script works and is able to display text on the screen. 
#It is able to take in a number from the user and display a joke based on the number. 
#The joke is generated by the ICTjokes model. 
#The joke is displayed on the screen in a typewriter effect. 
#The user can enter a number between 1 and 5 to get a joke based on the topic. 
#The topics are Software, Hardware, Infrastructure, Media Design, and Business

#the file is listening to finger_count_output.txt and waits for digits 1 to 5 
#based on it it sends an input to LLM 
#handcontroller.py is the mediapipe file that is creating a txt output



import cv2 as cv
import numpy as np
import os
import time
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
from langchain_community.chat_models import ChatOllama
from langchain_core.output_parsers import StrOutputParser
from langchain_core.prompts import ChatPromptTemplate

class CharacterLoader:
    def __init__(self):
        self.character_index = {}
        self.load_character_index()

    def load_character_index(self):
        dir_path = os.path.dirname(os.path.abspath(__file__))
        font_dir = os.path.join(dir_path, "font")
        files = [f for f in os.listdir(font_dir) if f[-4:] == ".csv"]
        for file in files:
            file_path = os.path.join(font_dir, file)
            data = open(file_path, "r").read()
            data = [[[255., 255., 255.] if c == '1' else [0., 0., 0.] for c in line.split(',')] for line in data.split("\n")]
            self.character_index[chr(int(file[5:-4]))] = (np.array(data), len(data[0]), len(data))

    def get_character(self, character):
        return self.character_index[character]

class TextWriter:
    def __init__(self, character_loader):
        self.character_loader = character_loader

    def put_text(self, frame, text, start):
        column_start = start[1]
        cursor = start
        char_count = 0
        for c in text:
            if c == "\n" or char_count == 50:
                cursor = [cursor[0]+6, column_start]
                char_count = 0
                if c == "\n":
                    continue
            letter = self.character_loader.get_character(c)
            frame[cursor[0]:cursor[0]+letter[2], cursor[1]:cursor[1]+letter[1]] = letter[0]
            cursor[1] += letter[1]+1
            char_count += 1

class ChatInterface:
    

    def __init__(self, model_name, stream):
        self.llm = ChatOllama(model=model_name, stream=stream)
        self.prompt = ChatPromptTemplate.from_template("Tell me a short joke about {topic}. Do not start with Sure here is the joke... or similar.")
        self.chain = self.prompt | self.llm | StrOutputParser()

    def get_response(self, topic):
        return self.chain.invoke({"topic": topic})

class TextDisplay:
    def __init__(self, text_writer):
        self.text_writer = text_writer

    def display_text(self, text):
        for i in range(len(text) + 1):
            mat = np.zeros((40, 250, 3))
            self.text_writer.put_text(mat, text[:i], [1, 0])
            cv.namedWindow('text', cv.WINDOW_NORMAL)
            cv.resizeWindow('text', 1200, 600)
            cv.imshow("text", mat)
            cv.waitKey(200)
        cv.waitKey(5000)
        cv.destroyAllWindows()

class FileWatcher:
    def __init__(self, file_path, chat_interface, display):
        self.file_path = file_path
        self.chat_interface = chat_interface
        self.display = display
        self.topic_dict = {1: "Software", 2: "Hardware", 3: "Infrastructure", 4: "Media Design", 5: "Business"}

    def on_modified(self, event):
        with open(self.file_path, 'r') as file:
            lines = file.readlines()
            if lines:
                last_line = lines[-1].strip()
                if last_line.isdigit():
                    topic_num = int(last_line)
                    if 1 <= topic_num <= 5:
                        topic = self.topic_dict[topic_num]
                        response = self.chat_interface.get_response(topic)
                        self.display.display_text(response)

    def watch(self):
        event_handler = FileSystemEventHandler()
        event_handler.on_modified = self.on_modified
        observer = Observer()
        observer.schedule(event_handler, os.path.dirname(self.file_path), recursive=False)
        observer.start()
        try:
            while True:
                time.sleep(1)
        except KeyboardInterrupt:
            observer.stop()
        observer.join()

def main():
    loader = CharacterLoader()
    writer = TextWriter(loader)
    chat_interface = ChatInterface("ICTjokes", True)
    display = TextDisplay(writer)

    file_watcher = FileWatcher(r"C:\Users\artur\Downloads\EventDrivenArchitecture\finger_count_output.txt", chat_interface, display)
    file_watcher.watch()

if __name__ == "__main__":
    main()
